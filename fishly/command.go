package fishly

import (
	"fmt"

	"log"

	"runtime/debug"
)

type Request struct {
	// Options struct generated by command and filled-in by
	// command line parser. For builtins -- only a single
	// string may be saved to options
	Options interface{}

	// Flag indicating that request was interrupted
	Cancelled bool

	// Id assigned to this request (incremented, unique in single fishly session)
	// (assignment is done by interpreter loop)
	Id int

	// Name of the command or builtin
	commandName string
	// Reference to command object. Set to nil for builtins
	command Command
	// Token walker for accessing blocks, etc.
	walker *cmdCommandTokenWalker

	// Request for outputs (without channels & sinks being setup)
	pipeRqs     []IOPipeRequest
	formatterRq *IOFormatterRequest
	sinkRq      *IOSinkRequest

	// For output
	ioh *IOHandle
}

type Command interface {
	Handler

	// Returns true if this command can be used in the current context
	// Note that you may create multiple commands but with varying command
	// contexts (they should be exclusive, though)
	IsApplicable(ctx *Context) bool

	// Execute command
	Execute(ctx *Context, rq *Request) error
}

// Mixin for command which is available globally
type GlobalCommand struct {
}

// Holds both last error and index of last processed token (for pretty
// error messages)
type cmdProcessorError struct {
	cmd   *cmdCommandTokenWalker
	err   error
	index int
}

// Unlike regular commands, builtins don't have implementation as Command
// interface and treated very specially
var builtins = []string{
	// Walks over context state if argument of special kind is provided
	"cd",

	// Executes script specified as argument
	"source", ".",

	// Exits. Can have special optional argument
	"exit",

	// Reloads configuration files & etc.
	"schema",
}

func (cmd *GlobalCommand) IsApplicable(ctx *Context) bool {
	return true
}

// Checks if current token is a builtin and returns its string argument (if one exists)
func isBuiltin(name string) bool {
	for _, builtin := range builtins {
		if builtin == name {
			return true
		}
	}

	return false
}

// Generators for command/args/redirection errors with indexes
func (cmd *cmdCommandTokenWalker) newCommandError(err error) *cmdProcessorError {
	if err == nil {
		return nil
	}
	return &cmdProcessorError{
		cmd:   cmd,
		err:   err,
		index: cmd.command.command.start,
	}
}
func (cmd *cmdCommandTokenWalker) newArgumentError(err error, index int) *cmdProcessorError {
	if err == nil {
		return nil
	}
	return &cmdProcessorError{
		cmd:   cmd,
		err:   err,
		index: cmd.command.args.start + index,
	}
}
func (cmd *cmdCommandTokenWalker) newPositionalArgumentError(err error, argIndex int) *cmdProcessorError {
	if err == nil {
		return nil
	}

	// Find at least one token with corresponding index. If nothing found,
	// fallback to command error
	args := cmd.getArguments()
	for index, arg := range args {
		if arg.argIndex == argIndex {
			return cmd.newArgumentError(err, index)
		}
	}
	return cmd.newCommandError(err)
}
func (cmd *cmdCommandTokenWalker) newArgParserError(
	argParser *cmdArgumentParser) *cmdProcessorError {
	return &cmdProcessorError{
		cmd:   cmd,
		err:   argParser.LastError,
		index: cmd.command.args.start + argParser.index,
	}
}

// New-style parser of commands.
func (ctx *Context) prepareCommandRequest(cmd *cmdCommandTokenWalker) (rq *Request, err *cmdProcessorError) {
	rq = new(Request)
	rq.commandName = cmd.getFirstToken().token
	rq.walker = cmd

	// Try to find appropriate descriptor or
	descriptor, ok := ctx.availableCommands[rq.commandName]
	if !ok {
		return nil, cmd.newCommandError(fmt.Errorf(
			"Command '%s' not found or not applicable in '%s'", rq.commandName,
			ctx.GetCurrentState().URL().String()))
	}
	rq.command = ctx.cfg.getCommandFromDescriptor(descriptor)

	// Create options structure and parse it.
	// TODO: implement interpolation
	rq.Options = rq.command.NewOptions(ctx)
	argParser := cmd.parseArgs(rq.Options, ctx.interpolateArgument)
	if argParser.LastError != nil {
		return nil, cmd.newArgParserError(argParser)
	}

	for err == nil {
		redir := cmd.nextRedirection()
		if redir == nil {
			return
		}

		// TODO: handle shell and file redirection

		err = ctx.prepareRedirection(rq, redir)
	}

	return
}

func (ctx *Context) prepareRedirection(rq *Request, redir *cmdRedirTokenWalker) (err *cmdProcessorError) {
	if rq.sinkRq != nil {
		return redir.newCommandError(fmt.Errorf("Redirection cannot be used after sink"))
	}

	name := redir.getFirstToken().token
	descriptor, ok := ctx.cfg.ioHandlers[name]
	if !ok {
		return redir.newCommandError(fmt.Errorf("Unknown redirection directive '%s'", name))
	}

	switch descriptor.handlerLocalType {
	case hdlIOSink:
		sink := ctx.cfg.sinks[descriptor.handlerLocalIndex]
		return rq.createIOSinkRequest(ctx, sink, redir)
	case hdlIOFormatter:
		if rq.formatterRq != nil {
			return redir.newCommandError(fmt.Errorf("Formatter is already specified"))
		}

		formatter := ctx.cfg.formatters[descriptor.handlerLocalIndex]
		return rq.createIOFormatterRequest(ctx, formatter, redir)
	case hdlIOPipe:
		if rq.formatterRq != nil {
			return redir.newCommandError(fmt.Errorf("Cannot specify pipe after formatter"))
		}

		pipe := ctx.cfg.pipes[descriptor.handlerLocalIndex]
		return rq.addIOPipeRequest(ctx, pipe, redir)
	}

	return redir.newCommandError(fmt.Errorf("Unknown redirection handler type"))
}

func (ctx *Context) processRequest(rq *Request) (err error) {
	// Assign request id
	rq.Id = ctx.requestId
	ctx.requestId++

	// Really execute the command (and fallback if something bad will happen)
	cmdErr := ctx.executeRequest(rq)

	// Handle command & output errors
	if rq.ioh != nil && rq.ioh.err != nil {
		err = rq.ioh.err
		log.Printf("I/O handler exited with error: %s", err)
	}
	if cmdErr != nil {
		err = cmdErr
	}

	if err == nil {
		// If context has changed, perform necessary updates in context
		ctx.tick()
	} else {
		log.Printf("Command '%s' exited with error: %s", rq.commandName, err)
	}

	return nil
}

func (ctx *Context) executeRequest(rq *Request) error {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Command caused a panic: %v", r)
			log.Print(string(debug.Stack()))
		}
	}()

	// Setup cancel handler
	cancel := ctx.cfg.Cancel.Create(ctx, rq)
	go cancel.Wait()
	defer cancel.Reset()

	return rq.command.Execute(ctx, rq)
}
