package yatima

import (
	"io"
	"os"

	"bytes"
	"fmt"

	"errors"
)

// Index of actor instance in the model
type ActorIndex uint32

// Actor time mode specifies when %t entry point should be activated
// We do not currently variate this parameter as we expect that end-mode
// will be used only explicitly by REX-MON
type ActorTimeMode uint32

const (
	ActorTimeNone ActorTimeMode = iota
	ActorTimeWindow
	ActorTimeEnd
)

var (
	// Invalid models codes -- those models can't be used to synthesize
	// viable actor network.

	IMUnknownInput        error = errors.New("Unknown input")
	IMSelfConnectedActor  error = errors.New("Actor connected to itself")
	IMInputConnectedTwice error = errors.New("Actor connected to same input twice")
	IMTransitiveActor     error = errors.New("Duplicate model due to transitive actor")
	IMUnmatchedDataHint   error = errors.New("Data hint doesn't match")
	IMComputationalLoop   error = errors.New("Actor computational loop")
	IMDisconnectedActor   error = errors.New("Actor is disconnected")
)

func (mode ActorTimeMode) Name() string {
	switch mode {
	case ActorTimeNone:
		return "none"
	case ActorTimeWindow:
		return "window"
	case ActorTimeEnd:
		return "end"
	}

	return "???"
}

type Library struct {
	Programs []*Program
}

// Pin index entry in pin address space cluster:group:pin
//  0:0:_	-- zero pins (not connected to anywhere)
//	0:1+x:y -- actor x / output pin y
//  1+s:p:q -- input sequence s/p, input q
type PinIndex struct {
	Cluster, Group, Pin uint32
}

func (pin PinIndex) Encode() uint32 {
	if pin.Group > 0xFFFFFF || pin.Cluster > 0xFFFFFF {
		panic("Pin index exceeds limits")
	}

	return pin.Cluster<<20 | pin.Group<<8 | pin.Pin
}

func (pin *PinIndex) Decode(value uint32) {
	pin.Cluster = (value >> 20) & 0xFFFFFF
	pin.Group = (value >> 8) & 0xFFFFFF
	pin.Pin = value & 0xFF
}

func (pin PinIndex) IsZero() bool {
	return pin.Cluster == 0 && pin.Group == 0
}

func (pin PinIndex) Less(other PinIndex) bool {
	// (pin.Cluster, pin.Group, pin.Pin) < (other.Cluster, other.Group, other.Pin)
	return pin.Encode() < other.Encode()
}

// Pin defines an edge which interconnects input and actor or two actors,
// or actor output
type Pin struct {
	// Index is not defined here as we use offset in PinGroup as index of
	// TSF field or id of ActorInstance
	Name string
	Hint RegisterHintType
}

type Input struct {
	PinIndex

	// Address of the first entry point (others are single-linked list
	// using tail CALL instructions)
	EntryPoint uint32
}

type PinGroup struct {
	Name string
	Pins []Pin
}

type PinCluster struct {
	Name   string
	Groups []PinGroup
}

type ActorInstance struct {
	// Index of actor in program library
	ProgramIndex uint32

	TimeMode ActorTimeMode
	Inputs   []PinIndex
	Outputs  []Pin
}

type BaseModel struct {
	Actors  []ActorInstance
	Inputs  []PinCluster
	library *Library
}

type Model struct {
	Actors      []ActorInstance
	UnboundPins []*PinIndex

	base *BaseModel

	// For models generated by mutator but failed validation, contains
	// reference to corresponding error. Such models can't be used for training
	Error error
}

// Model mutator is a helper structure that generates mutated models from
// the base model.
type ModelMutator struct {
	base *BaseModel

	// Last generated model. Even if model failed to create because it doesn't
	// satifsfy checks, we return it accompanied with error (for tests
	// and debugging), but in this case we might reuse previous object for
	// next model
	last *Model

	// Index of the program which we tried to create. 0..n -- subprograms
	// from base model's library 0..n correspondingly, n+1 -- no subprogram
	programIndex uint32
}

func NewBaseModel(library *Library) *BaseModel {
	model := &BaseModel{
		Actors: make([]ActorInstance, 0, 1),
		Inputs: make([]PinCluster, 0, 2),

		library: library,
	}

	return model
}

func LoadLibrary(yabr *BinaryReader) (*Library, error) {
	library := new(Library)

	for {
		dir, err := yabr.ReadDirective()
		if err == io.EOF {
			break
		}
		if err == nil && dir.Type != BDProgram {
			err = yabr.IgnoreBlock()
		}
		if err != nil {
			return nil, err
		}

		prog, err := yabr.ReadProgram()
		if err != nil {
			return nil, err
		}

		library.Programs = append(library.Programs, prog)
	}

	return library, nil
}

func LoadLibraryFromPath(path string) (*Library, error) {
	inf, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer inf.Close()

	strf, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer strf.Close()

	yabr, err := NewReader(inf, strf)
	if err != nil {
		return nil, err
	}

	return LoadLibrary(yabr)
}

func (library *Library) FindProgram(name string) (uint32, *Program) {
	for progIndex, prog := range library.Programs {
		if prog.Name == name {
			return uint32(progIndex), prog
		}
	}

	return 0, nil
}

// Finds actor output at pinIndex for the actor identified by index
// (index returned by AddActor())
func (model *Model) FindActorOutput(actorIndex, pinIndex uint32) (pin PinIndex) {
	pin = PinIndex{
		Group: uint32(1 + actorIndex),
		Pin:   uint32(pinIndex),
	}

	if model.getPin(pin) == nil {
		return PinIndex{}
	}
	return
}

func (base *BaseModel) FindActorOutput(actorIndex, pinIndex uint32) (pin PinIndex) {
	model := Model{base: base, Actors: base.Actors}
	return model.FindActorOutput(actorIndex, pinIndex)
}

func (model *Model) FindInput(clusterName, groupName, pinName string) PinIndex {
	// Do not allow searching for unnamed inputs
	if len(clusterName) == 0 || len(groupName) == 0 || len(pinName) == 0 {
		return PinIndex{}
	}

	for clusterIndex, cluster := range model.base.Inputs {
		if cluster.Name == clusterName {
			for groupIndex, group := range cluster.Groups {
				if group.Name == group.Name {
					for pinIndex, pin := range group.Pins {
						if pin.Name == pinName {
							return PinIndex{
								Cluster: uint32(clusterIndex),
								Group:   uint32(groupIndex),
								Pin:     uint32(pinIndex),
							}
						}
					}
				}
			}
		}
	}

	return PinIndex{}
}

func (model *Model) getPin(pin PinIndex) *Pin {
	clusterIndex := pin.Cluster
	if clusterIndex == 0 {
		if pin.Group == 0 {
			return nil
		}

		// This is a networked pin corresponding to existing (?) actor
		pin.Group--
		if len(model.Actors) <= int(pin.Group) {
			return nil
		}

		actor := &model.Actors[pin.Group]
		if len(actor.Outputs) <= int(pin.Pin) {
			return nil
		}

		return &actor.Outputs[pin.Pin]
	}

	// This is an input pin -- take it from the base model
	pin.Cluster--
	if len(model.base.Inputs) <= int(pin.Cluster) {
		return nil
	}

	cluster := &model.base.Inputs[pin.Cluster]
	if len(cluster.Groups) <= int(pin.Group) {
		return nil
	}

	group := &cluster.Groups[pin.Group]
	if len(group.Pins) < int(pin.Group) {
		return nil
	}

	return &group.Pins[pin.Pin]
}

// This is kind of pin++ operation, but it checks if we're going beyond
// available range and adds "overflow" bit to higher coordinate. If there are
// no more pins are left, zero pin is returned. Note: it is expected that
// incoming pin is valid, use getInput() if unsure
func (model *Model) nextPin(pin PinIndex) (next PinIndex) {
	next = pin
	next.Pin++

nextActor:
	if next.Cluster == 0 {
		if next.Group == 0 {
			// Try first actor
			next = PinIndex{Group: 1}
			goto nextActor
		}

		if int(next.Group-1) >= len(model.Actors) {
			// No more actor outputs to try -- start with first input
			next = PinIndex{Cluster: 1}
			goto nextInputCluster
		}

		actor := &model.Actors[next.Group-1]
		if int(next.Pin) >= len(actor.Outputs) {
			// No more outputs in this actor -- start with next actor
			// or go to the inputs space
			next.Pin = 0
			next.Group++
			if int(next.Group-1) >= len(model.Actors) {
				next = PinIndex{Cluster: 1}
				goto nextInputCluster
			}

			goto nextActor
		}

		return next
	}

nextInputCluster:
	// No more input clusters -- we completed walking inputs and must
	// touch the next cluster / group / index
	if int(next.Cluster-1) >= len(model.base.Inputs) {
		return PinIndex{}
	}

	cluster := &model.base.Inputs[next.Cluster-1]
	group := &cluster.Groups[next.Group]

	if int(next.Pin) >= len(group.Pins) {
		next.Pin = 0
		next.Group++

		if int(next.Group) >= len(cluster.Groups) {
			next.Group = 0
			next.Cluster++
		}

		goto nextInputCluster
	}

	return next
}

// Create actor instance in model and return its index. name distinguishes
// program name for the actor body, inputs provide pin indeces (can be inputs
// or actor outputs or "zero"-pins not connected anywhere so they can be
// variated), and time mode for actors listening for certain timing events
func (base *BaseModel) AddActor(name string, timeMode ActorTimeMode, inputs []PinIndex) (uint32, error) {
	progIndex, prog := base.library.FindProgram(name)
	if prog == nil {
		return 0, fmt.Errorf("Program '%s' is not found", name)
	}
	if timeMode != ActorTimeNone && !base.programHasTimeEP(prog) {
		return 0, fmt.Errorf("Time signal is requested, but actor has no entry point")
	}
	for _, input := range inputs {
		fakeModel := Model{base: base}
		if !input.IsZero() && fakeModel.getPin(input) == nil {
			return 0, fmt.Errorf("Invalid input %v", input)
		}
	}

	actor := ActorInstance{
		ProgramIndex: progIndex,
		TimeMode:     timeMode,
		Inputs:       inputs,
		Outputs:      base.generateProgramOutputs(prog),
	}

	base.Actors = append(base.Actors, actor)
	return uint32(len(base.Actors) - 1), nil
}

// Generate output descriptor structures from program hints
func (base *BaseModel) generateProgramOutputs(prog *Program) (outputs []Pin) {
	outputs = make([]Pin, 0, 2)
	for _, hint := range prog.Hints {
		if hint.Register.isOutputRegister() {
			outputs = append(outputs, Pin{Name: hint.Name, Hint: hint.Hint})
		}
	}

	return
}

// Generate input indeces all bound to zero pin
func (base *BaseModel) generateProgramInputs(prog *Program) []PinIndex {
	rightInputIndex := -1
	for _, hint := range prog.Hints {
		if hint.Register.isInputRegister() {
			// If actor subprogram uses, say %i1 and %i2 registers (omits %i0),
			// this will break validator, so we map input indeces straight to
			// indeces in array. And yes, that will produce more mutations than
			// needed
			inputIndex := hint.Register.inputRegisterIndex()
			if inputIndex > rightInputIndex {
				rightInputIndex = inputIndex
			}
		}
	}

	return make([]PinIndex, rightInputIndex+1)
}

// Returns true if one of the program's entry points expects time event to
// be activated. If so, we expect that training actors will wait for training
// end event and other actors will use tick interval ("window")
func (base *BaseModel) programHasTimeEP(prog *Program) bool {
	for _, ep := range prog.EntryPoints {
		if ep.Register == RT {
			return true
		}
	}

	return false
}

// Add actor of custom type (determined by program index) not bound to anywhere
// (variator will try to commutate the thing)
func (model *Model) addUnboundActor(progIndex uint32) {
	prog := model.base.library.Programs[progIndex]

	actor := ActorInstance{
		ProgramIndex: progIndex,
		TimeMode:     ActorTimeNone,
		Inputs:       model.base.generateProgramInputs(prog),
		Outputs:      model.base.generateProgramOutputs(prog),
	}
	if model.base.programHasTimeEP(prog) {
		actor.TimeMode = ActorTimeWindow
	}

	model.Actors = append(model.Actors, actor)

	// Save unbound pin for variator consideration
	for inputIndex := range actor.Inputs {
		model.UnboundPins = append(model.UnboundPins, &actor.Inputs[inputIndex])
	}
}

// Generate model "signature" -- useful one-string descriptor for a model which
// is useful for strings and debugging
func (model *Model) Signature() string {
	encode := func(word, rot uint32) byte {
		word = (word + rot) % 32
		if word < 22 {
			return 'A' + byte(word)
		}

		word -= 22
		return '0' + byte(word)
	}

	buf := bytes.NewBuffer([]byte{})

	for index, actor := range model.Actors {
		if index > 0 {
			buf.WriteByte('-')
		}

		buf.WriteByte(encode(actor.ProgramIndex, 0))
		switch actor.TimeMode {
		case ActorTimeWindow:
			buf.WriteByte('W')
		case ActorTimeEnd:
			buf.WriteByte('E')
		}
		for _, input := range actor.Inputs {
			buf.WriteByte('.')
			buf.WriteByte(encode(input.Cluster, 22))
			buf.WriteByte(encode(input.Group, 22))
			buf.WriteByte(encode(input.Pin, 22))
		}
	}

	return buf.String()
}

// Create clone of the base model: copy all actors, but keep reference to base
// model to access inputs list
func (base *BaseModel) Clone() (model *Model) {
	model = &Model{base: base}

	for _, baseActor := range base.Actors {
		// Clone actor except its mutable part (inputs) which might be
		// rebound to other pins
		model.Actors = append(model.Actors, baseActor)
		actor := &model.Actors[len(model.Actors)-1]

		actor.Inputs = make([]PinIndex, len(baseActor.Inputs))
		for inputIndex, input := range baseActor.Inputs {
			actor.Inputs[inputIndex] = input
			if input.IsZero() {
				// Save unbound input for the variator consideration
				model.UnboundPins = append(model.UnboundPins, &actor.Inputs[inputIndex])
			}
		}
	}

	return model
}

// Creates new mutator object which iteratively
func (base *BaseModel) NewMutator() (mutator *ModelMutator) {
	return &ModelMutator{
		base: base,
	}
}

// Returns pointer to (immutable) model which can be used for training (if
// error wasn't returned meaning model is not useable)
func (mutator *ModelMutator) Next() *Model {
mutateModel:
	if int(mutator.programIndex) > len(mutator.base.library.Programs) {
		return nil
	}

	model := mutator.last

	// If we don't have last model or gave it to consumer, recreate it
	if model == nil || model.Error == nil {
		model = mutator.base.Clone()
		if int(mutator.programIndex) < len(mutator.base.library.Programs) {
			model.addUnboundActor(mutator.programIndex)
		}

		// Copy previous state to next model so we can mutate one index. Since
		// we have used same sequence of actions to build new model from base
		// (clone + optional add actor) we expect that both slices will have
		// same number elements, it is a serious bug if they don't
		if mutator.last != nil {
			for index := range model.UnboundPins {
				*model.UnboundPins[index] = *mutator.last.UnboundPins[index]
			}
		} else {
			firstPin := model.nextPin(PinIndex{})
			for index := range model.UnboundPins {
				*model.UnboundPins[index] = firstPin
			}
		}
	}

	if mutator.last != nil {
		var ofFlag bool
		for idx := 0; idx < len(model.UnboundPins); {
			// Mutate one pin index if applicable, and further pin indeces if
			// mutating current pin causes "overflow" (no more pins left to try)
			nextPin := model.nextPin(*model.UnboundPins[idx])

			if nextPin.IsZero() {
				if idx == (len(model.UnboundPins) - 1) {
					// Nothing to mutate more as all pin indeces were reset to
					// zeroes try with next seeded actor (or complete)
					mutator.last = nil
					mutator.programIndex++
					goto mutateModel
				}

				// Retry mutating this pin as it generated 0-pin this time
				ofFlag = true
				*model.UnboundPins[idx] = PinIndex{}
				continue
			}

			*model.UnboundPins[idx] = nextPin

			// Advance state: if no overflow happened last time (reset pin to
			// zero), we got valid mutation, otherwise promite overflow to
			// following indeces
			if !ofFlag {
				break
			}
			ofFlag = false
			idx++
		}

	}

	mutator.last = model
	model.Validate()
	return model
}

func (model *Model) Validate() error {
	model.Error = model.validate()
	return model.Error
}

func (model *Model) validate() error {
	// First pass -- detect simplest actor errors
	for actorIndex, actor := range model.Actors {
		for idx, input := range actor.Inputs {
			if input.Cluster == 0 && input.Group == uint32(actorIndex+1) {
				return IMSelfConnectedActor
			}

			for idx2, input2 := range actor.Inputs {
				if idx != idx2 && input == input2 {
					return IMInputConnectedTwice
				}
			}
		}

		prog := model.base.library.Programs[actor.ProgramIndex]
		for _, hint := range prog.Hints {
			if !hint.Register.isInputRegister() {
				continue
			}

			inputIndex := hint.Register.inputRegisterIndex()
			pin := model.getPin(actor.Inputs[inputIndex])
			if pin == nil {
				return IMUnknownInput
			}

			if pin.Hint != hint.Hint {
				return IMUnmatchedDataHint
			}
		}

		for _, hint := range prog.TransHints {
			ii0 := hint.Register0.inputRegisterIndex()
			ii1 := hint.Register1.inputRegisterIndex()

			if !actor.Inputs[ii0].Less(actor.Inputs[ii1]) {
				// In transitive actors we check only for one combination, say
				// A.101.102 and reject A.102.101 as it produces same results,
				// so reject it here
				return IMTransitiveActor
			}
		}
	}

	// Now the hardest part -- detect loops and disconnected actors (last are
	// the actor which doesn't participate in producing final values)
	visited := make(map[int]int)
	for actorIndex := range model.base.Actors {
		if model.hasActorLoop(visited, actorIndex, nil) {
			return IMComputationalLoop
		}
	}
	for actorIndex := range model.Actors {
		if _, ok := visited[actorIndex]; !ok {
			return IMDisconnectedActor
		}
	}

	return nil
}

func (model *Model) hasActorLoop(visited map[int]int, index int, indeces []int) bool {
	visited[index]++
	actor := &model.Actors[index]
	for _, input := range actor.Inputs {
		if input.Cluster > 0 {
			// Usual input -- cannot produce a loop
			continue
		}

		childIndex := int(input.Group - 1)
		for _, parentIndex := range indeces {
			if parentIndex == childIndex {
				fmt.Println(indeces)
				return true
			}
		}

		childIndeces := make([]int, len(indeces), len(indeces)+1)
		copy(childIndeces, indeces)
		childIndeces = append(childIndeces, index)

		if model.hasActorLoop(visited, childIndex, childIndeces) {
			return true
		}
	}

	return false
}
